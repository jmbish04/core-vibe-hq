# Agent Development Instructions

This document contains critical rules and patterns that must be followed when developing new features or making changes to the codebase.

## Infrastructure Model

### ⚠️ CRITICAL: Workers Infrastructure

**This project uses paid Cloudflare Workers ($5/month per worker), NOT Workers for Platforms.**

- ✅ **Paid Workers**: Standard Cloudflare Workers with service bindings
- ❌ **Workers for Platforms**: **MUST NOT** use `dispatch_namespaces` or any Workers for Platforms features
- ❌ **Dispatch Namespaces**: **DO NOT** add `dispatch_namespaces` to any `wrangler.jsonc` files
- ❌ **Dynamic Dispatch**: **DO NOT** use `DispatchNamespace` or dynamic dispatch features

**All communication between workers uses:**
- Service bindings (RPC entrypoints)
- Standard HTTP fetch between workers
- **NOT** dispatch namespaces or Workers for Platforms APIs

**If you see references to `DISPATCHER` or `DISPATCH_NAMESPACE` in code:**
- These are legacy/unused and should be removed or refactored
- Do not add new code that depends on dispatch namespaces
- The `DISPATCH_NAMESPACE` environment variable in `orchestrator/wrangler.jsonc` is legacy and should be removed when dispatch-related code is fully refactored

## Database Architecture

### ⚠️ CRITICAL: D1 Database Access Pattern

**Only the orchestrator worker has direct D1 database bindings.**

- ✅ **Orchestrator** (`orchestrator/wrangler.jsonc`): Has `DB` binding to D1
- ❌ **Factories** (`apps/*/wrangler.jsonc`): **MUST NOT** have D1 bindings

### Database Communication Rules

1. **Factory → Database**: All database operations from factories must go through orchestrator service bindings (RPC entrypoints)
   - Use service bindings: `ORCHESTRATOR_*` (defined in `wrangler.base.jsonc`)
   - Entrypoints available: `GitHubOps`, `TaskOps`, `FactoryOps`, `DeliveryOps`, `LoggingOps`, `OpsOps`, `HealthCheckOps`
   - **If a new feature requires database access from a factory, create a new entrypoint in orchestrator**

2. **Orchestrator → Factory**: All communication from orchestrator to factories must use service bindings
   - Add service bindings in `orchestrator/wrangler.jsonc`
   - Factories must expose entrypoints (WorkerEntrypoint classes) for orchestrator to call
   - **If orchestrator needs to send orders/commands to a factory, add an entrypoint to that factory**

### Example: Adding Database Access from Factory

**Scenario**: Agent factory needs to query project requirements

**Solution**:
1. Create new entrypoint in `orchestrator/worker/entrypoints/` (e.g., `ProjectOps.ts`)
2. Add service binding in factories' `wrangler.base.jsonc`:
   ```jsonc
   {
     "binding": "ORCHESTRATOR_PROJECT",
     "service": "vibehq-orchestrator",
     "entrypoint": "ProjectOps"
   }
   ```
3. Factory calls via: `env.ORCHESTRATOR_PROJECT.getRequirements(...)`

## Database Technologies

### Drizzle ORM and Kysely

**All D1 database operations MUST use Drizzle ORM and Kysely:**

- ✅ **Schema Definition**: Use Drizzle ORM (`sqliteTable`, `text`, `integer`, etc.) in `orchestrator/worker/database/schema.ts`
- ✅ **Queries**: Use Drizzle ORM for queries (`db.db.select()`, `db.db.insert()`, etc.)
- ✅ **Type Safety**: Use Kysely types where needed (e.g., `Selectable<TasksTable>`)
- ❌ **Never**: Use raw SQL queries or `env.DB.prepare()` directly
- ❌ **Never**: Use raw SQL in migrations - migrations are auto-generated by Drizzle Kit from schema definitions

### Migration Management

**Migrations folder location:**
- ✅ **Only**: `orchestrator/migrations/` contains SQL migration files
- ❌ **Never**: Create migrations folders under `apps/` or factories
- ❌ **Never**: Manually create SQL migration files - use Drizzle Kit to generate from schema

**Migration Workflow:**
1. Define/update tables in `orchestrator/worker/database/schema.ts` using Drizzle ORM
2. Run `npm run db:generate` in orchestrator directory
3. Drizzle Kit automatically generates SQL migration files in `orchestrator/migrations/`
4. Apply migrations with `npm run db:migrate:local` or `npm run db:migrate:remote`

## Documentation

### Markdown Documentation Files

**When creating new documentation files:**

- ✅ **Location**: Store in `docs/` folder at repository root, organized by category (e.g., `docs/development/`, `docs/database/`, etc.)
- ✅ **Overview**: Update `docs/OVERVIEW.md` with new documentation entry
- ❌ **Don't**: Create docs in subdirectories outside `docs/` (e.g., `orchestrator/migrations/README.md`)
- ❌ **Don't**: Move main `README.md` or agent instruction files outside `docs/`

**Format for `docs/OVERVIEW.md`:**
```markdown
## [Documentation Title]

**File**: `docs/category/filename.md`
**Description**: Brief description of what this document covers
```

### Example Documentation Structure

```
docs/
├── OVERVIEW.md              # Table of contents for all docs
├── README.md                # Main project documentation
├── development/
│   └── agent-instructions.md    # This file
├── database/
│   └── migrations.md           # Migration strategy and workflow
└── [other-categories]/          # Other documentation
```

## Service Binding Patterns

### Factory Needs Database Access

1. Identify required database operation
2. Check if orchestrator entrypoint exists (`orchestrator/worker/entrypoints/`)
3. If not, create new entrypoint class extending `BaseWorkerEntrypoint`
4. Add service binding to `wrangler.base.jsonc`:
   ```jsonc
   {
     "binding": "ORCHESTRATOR_[OPERATION]",
     "service": "vibehq-orchestrator",
     "entrypoint": "[OperationName]Ops"
   }
   ```
5. Factory calls via service binding: `env.ORCHESTRATOR_[OPERATION].method(...)`

### Orchestrator Needs Factory Functionality

1. Add service binding in `orchestrator/wrangler.jsonc`:
   ```jsonc
   {
     "binding": "[FACTORY]_SERVICE",
     "service": "[factory-name]"
   }
   ```
2. Factory must expose entrypoint (WorkerEntrypoint class)
3. Orchestrator calls via: `env.[FACTORY]_SERVICE.fetch(request)` or RPC methods

## Code Organization

### Agents Folder Structure

- **Location**: 
  - Base class: `@shared/agents/base/BaseAgent.ts` (shared across all workers)
  - Orchestrator agents: `orchestrator/worker/agents/`
  - Apps worker agents: Can be in their respective worker directories
- **Base Class**: All agents extend `BaseAgent` from `@shared/agents/base/BaseAgent.ts`
  - Works in orchestrator (direct DB access) and apps workers (via `ORCHESTRATOR_LOGGING` service binding)
  - Automatically routes logging to the appropriate mechanism
- **Logging**: All agents automatically log to D1 and observability
  - Orchestrator: Direct database access
  - Apps workers: Via `ORCHESTRATOR_LOGGING` service binding
- **Database**: 
  - Orchestrator agents: Use orchestrator's database service directly
  - Apps worker agents: Use orchestrator service bindings for database operations

### Entrypoints

- **Location**: `orchestrator/worker/entrypoints/`
- **Pattern**: Each entrypoint is a class extending `BaseWorkerEntrypoint`
- **Purpose**: Expose RPC methods for factories to call
- **Naming**: `[Operation]Ops.ts` (e.g., `TaskOps.ts`, `GitHubOps.ts`)

## Deployment Requirements

### ⚠️ CRITICAL: Every Worker Must Have a Deploy Workflow

**Every worker in this project MUST have a corresponding GitHub Actions workflow file in `.github/workflows/`:**

- ✅ **Orchestrator**: `.github/workflows/deploy-orchestrator.yml`
- ✅ **Agent Factory**: `.github/workflows/deploy-agent-factory.yml`
- ✅ **Data Factory**: `.github/workflows/deploy-data-factory.yml`
- ✅ **Services Factory**: `.github/workflows/deploy-services-factory.yml`
- ✅ **UI Factory**: `.github/workflows/deploy-ui-factory.yml`
- ✅ **Ops Specialists**: `.github/workflows/deploy-ops-specialists.yml` (covers both conflict and delivery-report specialists)

**When creating a new worker:**
1. Create the worker directory under `apps/` or at root (for orchestrator)
2. **MUST** create a corresponding deploy workflow in `.github/workflows/deploy-[worker-name].yml`
3. The workflow should:
   - Trigger on pushes to `main` branch when worker files change
   - Support `workflow_dispatch` for manual deployment
   - Install dependencies (using `npm ci` or `bun install`)
   - Deploy using `wrangler-action@v3` or `wrangler deploy`

**Workflow naming convention**: `deploy-[worker-name].yml` (kebab-case)

## Problem Resolution Before Feature Completion

### ⚠️ CRITICAL: Clear All Problems Before Reporting Completion

**Before reporting that a feature is fully implemented, you MUST:**

1. **Run comprehensive problem check**: `npm run problems`
   - This runs TypeScript type checking (`typecheck:all`)
   - Runs linting (`lint:all`)
   - Generates Wrangler types (`types:all`)

2. **Resolve ALL errors**:
   - Fix all TypeScript compilation errors
   - Fix all linting errors
   - Ensure all `wrangler types` commands succeed
   - Fix any import/export issues
   - Fix any missing dependencies

3. **Verify no regressions**:
   - Ensure existing functionality still works
   - Check that no new warnings were introduced
   - Verify all workers can still deploy

4. **Only after all problems are resolved**, report feature completion

**Use the Problems tab in Cursor/VSCode as your reference** - the `npm run problems` script should mirror what you see there.

## Checklist for New Features

When adding a feature that involves database access or infrastructure:

- [ ] Does it use Workers for Platforms features?
  - [ ] If yes: **STOP** - This project uses paid Workers only, not Workers for Platforms
  - [ ] Remove any `dispatch_namespaces` or dispatch-related code
  - [ ] Use service bindings or HTTP fetch instead

- [ ] Does it require database access from an apps/ worker?
  - [ ] If yes: Create orchestrator entrypoint
  - [ ] Add service binding to `@shared/base/wrangler.base.jsonc`
  - [ ] Apps worker calls via service binding
- [ ] Does it require orchestrator to call an apps/ worker?
  - [ ] If yes: Add service binding to `orchestrator/wrangler.jsonc`
  - [ ] Apps worker exposes WorkerEntrypoint class
- [ ] Are new tables needed?
  - [ ] Add to `orchestrator/worker/database/schema.ts` using Drizzle
  - [ ] Run `npm run db:generate` to create migration
  - [ ] Migrations go in `orchestrator/migrations/` only
- [ ] Is documentation needed?
  - [ ] Create markdown file in appropriate `docs/[category]/` folder
  - [ ] Update `docs/OVERVIEW.md` with entry
- [ ] **Does it create a new worker?**
  - [ ] If yes: **MUST** create deploy workflow in `.github/workflows/deploy-[worker-name].yml`
  - [ ] Workflow includes proper triggers and deployment steps
- [ ] **Before reporting completion:**
  - [ ] Run `npm run problems` and resolve ALL errors
  - [ ] Verify no TypeScript errors (`typecheck:all`)
  - [ ] Verify no linting errors (`lint:all`)
  - [ ] Verify Wrangler types generate successfully (`types:all`)
  - [ ] Check Problems tab in Cursor/VSCode - should be empty

## Quick Reference

| Need | Solution |
|------|----------|
| Factory needs DB access | Use orchestrator service binding entrypoint |
| Orchestrator needs factory | Add service binding, factory exposes entrypoint |
| New tables | Add to Drizzle schema, generate migration |
| New documentation | Create in `docs/[category]/`, update `docs/OVERVIEW.md` |
| Migrations location | Only `orchestrator/migrations/` |
| Database queries | Use Drizzle ORM, never raw SQL |
| New worker created | **MUST** create deploy workflow in `.github/workflows/` |
| Check all problems | Run `npm run problems` before reporting completion |
| Before feature complete | Clear ALL TypeScript, linting, and type errors |

