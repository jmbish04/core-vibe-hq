/**
 * Worker WebSocket Client Library (Minified)
 * Version 1.0.0 - Production Ready
 */
class WorkerWebSocketClient{constructor(e,t={}){this.url=e,this.options={autoReconnect:!0,reconnectInterval:5e3,maxReconnectAttempts:10,heartbeatInterval:3e4,requestTimeout:1e4,...t},this.ws=null,this.isConnected=!1,this.isConnecting=!1,this.reconnectAttempts=0,this.heartbeatTimer=null,this.requestId=0,this.eventHandlers=new Map,this.pendingRequests=new Map,this.subscriptions=new Map,this.onConnect=null,this.onDisconnect=null,this.onError=null,this.onReconnecting=null}async connect(){return this.isConnected||this.isConnecting?Promise.resolve():new Promise(((e,t)=>{this.isConnecting=!0;try{this.ws=new WebSocket(this.url),this.ws.onopen=()=>{this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.startHeartbeat(),this.emit("connect"),this.onConnect&&this.onConnect(),e()},this.ws.onmessage=e=>{this.handleMessage(e.data)},this.ws.onclose=e=>{this.handleDisconnect(e)},this.ws.onerror=e=>{this.isConnecting=!1,this.emit("error",e),this.onError&&this.onError(e),t(e)}}catch(e){this.isConnecting=!1,t(e)}}))}disconnect(){this.options.autoReconnect=!1,this.stopHeartbeat(),this.ws&&(this.ws.close(),this.ws=null),this.isConnected=!1,this.isConnecting=!1;for(const[e,{reject:t}]of this.pendingRequests)t(new Error("Connection closed"));this.pendingRequests.clear()}async request(e,t={},n=null){if(!this.isConnected)throw new Error("WebSocket not connected");const s=++this.requestId,o={id:s,type:"request",request_type:e,data:t,timestamp:Date.now()};return new Promise(((e,t)=>{const i=n||this.options.requestTimeout,r=setTimeout((()=>{this.pendingRequests.delete(s),t(new Error(`Request timeout: ${e}`))}),i);this.pendingRequests.set(s,{resolve:t=>{clearTimeout(r),e(t)},reject:e=>{clearTimeout(r),t(e)}}),this.send(o)}))}send(e){if(!this.isConnected)throw new Error("WebSocket not connected");const t="string"==typeof e?e:JSON.stringify(e);this.ws.send(t)}subscribe(e,t){return this.subscriptions.has(e)||this.subscriptions.set(e,new Set),this.subscriptions.get(e).add(t),()=>{const n=this.subscriptions.get(e);n&&(n.delete(t),0===n.size&&this.subscriptions.delete(e))}}unsubscribe(e,t=null){if(t){const n=this.subscriptions.get(e);n&&n.delete(t)}else this.subscriptions.delete(e)}on(e,t){this.eventHandlers.has(e)||this.eventHandlers.set(e,new Set),this.eventHandlers.get(e).add(t)}off(e,t){const n=this.eventHandlers.get(e);n&&n.delete(t)}emit(e,t=null){const n=this.eventHandlers.get(e);if(n)for(const s of n)try{s(t)}catch(t){console.error(`Error in event handler for ${e}:`,t)}}handleMessage(e){try{const t=JSON.parse(e);if("response"===t.type&&t.id){const e=this.pendingRequests.get(t.id);return void(e&&(this.pendingRequests.delete(t.id),t.success?e.resolve(t.data):e.reject(new Error(t.error||"Request failed"))))}if("event"===t.type||"log"===t.type||"metrics"===t.type)return this.notifySubscribers(t.type,t),void this.emit("message",t);if("pong"===t.type)return void this.emit("pong",t);this.emit("message",t)}catch(t){console.error("Error parsing WebSocket message:",t,e),this.emit("error",t)}}notifySubscribers(e,t){const n=this.subscriptions.get(e);if(n)for(const s of n)try{s(t)}catch(t){console.error(`Error in subscription handler for ${e}:`,t)}}handleDisconnect(e){this.isConnected=!1,this.stopHeartbeat(),this.emit("disconnect",e),this.onDisconnect&&this.onDisconnect(e),this.options.autoReconnect&&this.reconnectAttempts<this.options.maxReconnectAttempts&&(this.reconnectAttempts++,this.emit("reconnecting",this.reconnectAttempts),this.onReconnecting&&this.onReconnecting(this.reconnectAttempts),setTimeout((()=>{this.isConnected||this.connect().catch((e=>{console.error("Reconnection failed:",e)}))}),this.options.reconnectInterval))}startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval((()=>{this.isConnected&&this.send({type:"ping",timestamp:Date.now()})}),this.options.heartbeatInterval)}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=null)}getStatus(){return{connected:this.isConnected,connecting:this.isConnecting,reconnectAttempts:this.reconnectAttempts,url:this.url}}async executeCommand(e){return this.request("command",{command:e})}async getMetrics(){return this.request("metrics")}async getHealth(){return this.request("health")}subscribeLogs(e){return this.subscribe("log",e)}subscribeMetrics(e){return this.subscribe("metrics",e)}subscribeEvents(e){return this.subscribe("event",e)}}"undefined"!=typeof module&&module.exports&&(module.exports=WorkerWebSocketClient),"undefined"!=typeof window&&(window.WorkerWebSocketClient=WorkerWebSocketClient),"undefined"!=typeof self&&(self.WorkerWebSocketClient=WorkerWebSocketClient);
